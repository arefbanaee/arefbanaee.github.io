import _react.PropTypes from "prop-types";

("use strict");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BrushedArea = undefined;

var _slicedToArray = (function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (
        var _i = arr[Symbol.iterator](), _s;
        !(_n = (_s = _i.next()).done);
        _n = true
      ) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError(
        "Invalid attempt to destructure non-iterable instance"
      );
    }
  };
})();

var _extends =
  Object.assign ||
  function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };

var _createClass = (function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _utils = require("./utils.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _objectWithoutProperties(obj, keys) {
  var target = {};
  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }
  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  }
  return call && (typeof call === "object" || typeof call === "function")
    ? call
    : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError(
      "Super expression must either be null or a function, not " +
        typeof superClass
    );
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf
      ? Object.setPrototypeOf(subClass, superClass)
      : (subClass.__proto__ = superClass);
}

var mouseIsInBounds = function mouseIsInBounds(mouseEvent, rectangle) {
  var x = mouseEvent.pageX,
    y = mouseEvent.pageY;
  var top = rectangle.top,
    left = rectangle.left,
    right = rectangle.right,
    bottom = rectangle.bottom;

  return x >= left && x <= right && y >= top && y <= bottom;
};

var mouseMoveExceedsThreshold = function mouseMoveExceedsThreshold(
  _ref,
  threshold
) {
  var mx0 = _ref.mx0,
    mx1 = _ref.mx1,
    my0 = _ref.my0,
    my1 = _ref.my1;
  return (
    threshold > 0 &&
    Math.hypot(Math.abs(mx0 - mx1), Math.abs(my0 - my1)) >= threshold
  );
};

var getBrushedState = function getBrushedState(state, bounds) {
  var mx0 = state.mx0,
    my0 = state.my0,
    mx1 = state.mx1,
    my1 = state.my1;
  var left = bounds.left,
    top = bounds.top;

  return {
    y: Math.min(my1, my0) - top,
    x: Math.min(mx1, mx0) - left,
    height: Math.abs(my1 - my0),
    width: Math.abs(mx1 - mx0)
  };
};

var ReactBrush = (function(_Component) {
  _inherits(ReactBrush, _Component);

  function ReactBrush(props) {
    _classCallCheck(this, ReactBrush);

    var _this = _possibleConstructorReturn(
      this,
      (ReactBrush.__proto__ || Object.getPrototypeOf(ReactBrush)).call(
        this,
        props
      )
    );

    _this.state = {
      mouseDown: false,
      isBrushing: false,

      mx0: 0,
      my0: 0,
      mx1: 0,
      my1: 0
    };

    _this.handleMouseDown = function(e) {
      var button = e.button,
        mx0 = e.pageX,
        my0 = e.pageY;
      var _this$props = _this.props,
        mouseDownThreshold = _this$props.mouseDownThreshold,
        mouseMoveThreshold = _this$props.mouseMoveThreshold;

      var delayBrush = mouseDownThreshold > 0 || moveMoveThreshold > 0;

      if (button === 0) {
        _this.setState(
          {
            mouseDown: true,
            isBrushing: delayBrush ? false : true,
            mx0: mx0,
            my0: my0,
            mx1: mx0,
            my1: my0
          },
          function() {
            if (mouseDownThreshold > 0) {
              _this.clearMouseDownTimer();
              _this._mouseDownTimer = setTimeout(function() {
                _this.setState({ isBrushing: true });
              }, mouseDownThreshold);
            }
          }
        );
      }

      var onMouseDown = _this.props.onMouseDown;

      if (typeof onMouseDown === "function") {
        onMouseDown(e);
      }
    };

    _this.handleMouseUp = function(e) {
      var button = e.button,
        mx1 = e.pageX,
        my1 = e.pageY;

      if (e.button === 0) {
        _this.clearMouseDownTimer();

        _this.setState({
          mouseDown: false,
          isBrushing: false,
          mx1: mx1,
          my1: my1
        });
      }

      var onMouseUp = _this.props.onMouseUp;

      if (
        typeof onMouseUp === "function" &&
        mouseIsInBounds(e, _this.getBounds())
      ) {
        _this.props.onMouseUp(e);
      }
    };

    _this.mouseMove = function(e) {
      var mx1 = e.pageX,
        my1 = e.pageY;

      _this.setState(function(_ref2) {
        var mouseDown = _ref2.mouseDown,
          isBrushing = _ref2.isBrushing;

        var state = {
          mx1: mx1,
          my1: my1
        };

        // end here if the mouse is not down or brush is already in progress
        if (!mouseDown || isBrushing) {
          return state;
        }

        // end here if the mouse has not moved far enough to trigger a brush
        var _this$state = _this.state,
          mx0 = _this$state.mx0,
          my0 = _this$state.my0;

        if (
          !mouseMoveExceedsThreshold(
            { mx1: mx1, my1: my1, mx0: mx0, my0: my0 },
            _this.props.mouseMoveThreshold
          )
        ) {
          return state;
        }

        _this.clearMouseDownTimer();
        state.isBrushing = true;

        return state;
      });

      var onMouseMove = _this.props.onMouseMove;

      if (
        typeof onMouseMove === "function" &&
        mouseIsInBounds(e, _this.getBounds())
      ) {
        onMouseMove(e);
      }
    };

    _this._userSelectStyles = {};
    return _this;
  }

  _createClass(ReactBrush, [
    {
      key: "getBounds",
      value: function getBounds() {
        if (!this.container) {
          return { top: 0, left: 0, right: 0, bottom: 0 };
        }
        var _document$documentEle = document.documentElement,
          clientTop = _document$documentEle.clientTop,
          clientLeft = _document$documentEle.clientLeft;
        var _window = window,
          pageYOffset = _window.pageYOffset,
          pageXOffset = _window.pageXOffset;

        var _container$getBoundin = this.container.getBoundingClientRect(),
          top = _container$getBoundin.top,
          left = _container$getBoundin.left;

        var _props = this.props,
          height = _props.height,
          width = _props.width;

        var vertOffset = pageYOffset - clientTop;
        var horizontalOffset = pageXOffset - clientLeft;

        return {
          top: top + vertOffset,
          left: left + horizontalOffset,
          bottom: top + vertOffset + height,
          right: left + horizontalOffset + width
        };
      }
    },
    {
      key: "clearMouseDownTimer",
      value: function clearMouseDownTimer() {
        if (this._mouseDownTimer) {
          clearTimeout(this._mouseDownTimer);
          this._mouseDownTimer = null;
        }
      }
    },
    {
      key: "brushStart",
      value: function brushStart(nextState) {
        // prevent text in other elements from being selected during a brush
        var delStyle = document.documentElement.style;
        var userSelect = delStyle.userSelect,
          webkitUserSelect = delStyle.webkitUserSelect,
          mozUserSelect = delStyle.mozUserSelect,
          msUserSelect = delStyle.msUserSelect;

        this._userSelectStyles = {
          userSelect: userSelect,
          webkitUserSelect: webkitUserSelect,
          mozUserSelect: mozUserSelect,
          msUserSelect: msUserSelect
        };

        delStyle.userSelect = "none";
        delStyle.webkitUserSelect = "none";
        delStyle.mozUserSelect = "none";
        delStyle.msUserSelect = "none";

        var onBrushStart = this.props.onBrushStart;

        if (typeof onBrushStart === "function") {
          onBrushStart(getBrushedState(nextState, this.getBounds()));
        }
      }
    },
    {
      key: "brushStop",
      value: function brushStop(nextState) {
        // restore previous user-select styles
        var delStyle = document.documentElement.style;
        var _userSelectStyles = this._userSelectStyles,
          userSelect = _userSelectStyles.userSelect,
          webkitUserSelect = _userSelectStyles.webkitUserSelect,
          mozUserSelect = _userSelectStyles.mozUserSelect,
          msUserSelect = _userSelectStyles.msUserSelect;

        delStyle.userSelect = userSelect;
        delStyle.webkitUserSelect = webkitUserSelect;
        delStyle.mozUserSelect = mozUserSelect;
        delStyle.msUserSelect = msUserSelect;

        var onBrushStop = this.props.onBrushStop;

        if (typeof onBrushStop === "function") {
          onBrushStop(getBrushedState(nextState, this.getBounds()));
        }
      }
    },
    {
      key: "brushChange",
      value: function brushChange(nextState) {
        var onBrushChange = this.props.onBrushChange;

        if (typeof onBrushChange === "function") {
          onBrushChange(getBrushedState(nextState, this.getBounds()));
        }
      }
    },
    {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, _ref3) {
        var nextx = _ref3.mx1,
          nexty = _ref3.my1,
          nextState = _objectWithoutProperties(_ref3, ["mx1", "my1"]);

        var _state = this.state,
          x = _state.mx1,
          y = _state.my1,
          state = _objectWithoutProperties(_state, ["mx1", "my1"]);

        if (
          !(0, _utils.shallowEqual)(this.props, nextProps) ||
          !(0, _utils.shallowEqual)(state, nextState)
        ) {
          return true;
        }

        // only re-render on mouse movement if the user is actively brushing
        if (nextState.isBrushing === true) {
          return x !== nextx || y !== nexty;
        }

        return false;
      }
    },
    {
      key: "componentWillUpdate",
      value: function componentWillUpdate(nextProps, nextState) {
        var _state2 = this.state,
          isBrushing = _state2.isBrushing,
          x = _state2.x1,
          y = _state2.y1;
        var nextIsBrushing = nextState.isBrushing,
          nextx = nextState.x1,
          nexty = nextState.y1;

        // are we starting a brush?

        if (nextIsBrushing === true && isBrushing === false) {
          this.brushStart(nextState);
          return;
        }

        // are we ending a brush?
        if (nextIsBrushing === false && isBrushing === true) {
          this.brushStop(nextState);
          return;
        }

        // are we updating the brush?
        if (nextIsBrushing === true && (nextx != x || nexty != y)) {
          this.brushChange(nextState);
          return;
        }
      }
    },
    {
      key: "componentWillMount",
      value: function componentWillMount() {
        window.addEventListener("mouseup", this.handleMouseUp);
        window.addEventListener("mousemove", this.mouseMove);
      }
    },
    {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        window.removeEventListener("mouseup", this.handleMouseUp);
        window.removeEventListener("mousemove", this.mouseMove);
        this.clearMouseDownTimer();
      }
    },
    {
      key: "renderOverlay",
      value: function renderOverlay() {
        var _props2 = this.props,
          _props2$brushedArea = _props2.brushedArea,
          brushedArea =
            _props2$brushedArea === undefined
              ? _react2.default.createElement(BrushedArea, null)
              : _props2$brushedArea,
          height = _props2.height,
          width = _props2.width;

        var container = this.getBounds();
        var brush = getBrushedState(this.state, container);
        var brushProps = { brush: brush, container: container };

        var _state3 = this.state,
          brushStart = _state3.brushStart,
          mouseUp = _state3.mouseUp;
        var isBrushing = this.state.isBrushing;

        return _react2.default.createElement(
          "g",
          null,
          isBrushing &&
            ((0, _react.isValidElement)(brushedArea)
              ? (0, _react.cloneElement)(brushedArea, brushProps)
              : brushedArea(brushProps)),
          _react2.default.createElement("rect", {
            width: width,
            height: height,
            style: { opacity: 0, cursor: isBrushing ? "crosshair" : "auto" }
          })
        );
      }
    },
    {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _props3 = this.props,
          onMouseUp = _props3.onMouseUp,
          onMouseMove = _props3.onMouseMove,
          onBrushStop = _props3.onBrushStop,
          onBrushStart = _props3.onBrushStart,
          onBrushChange = _props3.onBrushChange,
          brushedArea = _props3.brushedArea,
          mouseMoveThreshold = _props3.mouseMoveThreshold,
          mouseDownThreshold = _props3.mouseDownThreshold,
          Tag = _props3.tag,
          children = _props3.children,
          width = _props3.width,
          height = _props3.height,
          onMouseDown = _props3.onMouseDown,
          props = _objectWithoutProperties(_props3, [
            "onMouseUp",
            "onMouseMove",
            "onBrushStop",
            "onBrushStart",
            "onBrushChange",
            "brushedArea",
            "mouseMoveThreshold",
            "mouseDownThreshold",
            "tag",
            "children",
            "width",
            "height",
            "onMouseDown"
          ]);

        if (Tag === "svg") {
          props.height = height;
          props.width = width;
        }

        var _state4 = this.state,
          brushStart = _state4.brushStart,
          mouseUp = _state4.mouseUp;
        var isBrushing = this.state.isBrushing;

        return _react2.default.createElement(
          Tag,
          _extends(
            {
              onMouseDown: this.handleMouseDown
            },
            props,
            {
              ref: function ref(r) {
                _this2.container = r;
              }
            }
          ),
          !isBrushing && this.renderOverlay(),
          children,
          isBrushing && this.renderOverlay()
        );
      }
    }
  ]);

  return ReactBrush;
})(_react.Component);

ReactBrush.propTypes = {
  width: _react.PropTypes.number.isRequired,
  height: _react.PropTypes.number.isRequired,
  onBrushStart: _react.PropTypes.func,
  onBrushStop: _react.PropTypes.func,
  onBrushChange: _react.PropTypes.func,
  brushedArea: _react.PropTypes.oneOfType([_react.PropTypes.element, _react.PropTypes.func]),
  tag: _react.PropTypes.string,
  mouseMoveThreshold: _react.PropTypes.number,
  mouseDownThreshold: _react.PropTypes.number
};
ReactBrush.defaultProps = {
  tag: "svg",
  mouseDownThreshold: 500,
  mouseMoveThreshold: 5
};
exports.default = ReactBrush;
var BrushedArea = (exports.BrushedArea = function BrushedArea(_ref4) {
  var brush = _ref4.brush,
    container = _ref4.container,
    style = _ref4.style,
    fullWidth = _ref4.fullWidth,
    fullHeight = _ref4.fullHeight,
    className = _ref4.className;

  if (!(container && brush)) {
    return null;
  }

  var brushWidth = brush.width,
    brushHeight = brush.height,
    brushX = brush.x,
    brushY = brush.y;
  var top = container.top,
    left = container.left,
    right = container.right,
    bottom = container.bottom;

  var containerWidth = right - left;
  var containterHeight = bottom - top;

  var x = 0;
  var y = 0;
  var width = containerWidth;
  var height = containterHeight;

  if (!fullWidth) {
    var _ref5 =
      brushX < 0
        ? [0, brushWidth + brushX]
        : [
            brushX,
            brushX + brushWidth > containerWidth
              ? containerWidth - brushX
              : brushWidth
          ];

    var _ref6 = _slicedToArray(_ref5, 2);

    x = _ref6[0];
    width = _ref6[1];
  }
  if (!fullHeight) {
    var _ref7 =
      brushY < 0
        ? [0, brushHeight + brushY]
        : [
            brushY,
            brushY + brushHeight > containterHeight
              ? containterHeight - brushY
              : brushHeight
          ];

    var _ref8 = _slicedToArray(_ref7, 2);

    y = _ref8[0];
    height = _ref8[1];
  }

  return _react2.default.createElement("rect", {
    width: width,
    height: height,
    className: className,
    x: x,
    y: y,
    style: _extends({ fill: "black", opacity: 0.3 }, style)
  });
});

BrushedArea.propTypes = {
  container: _react.PropTypes.object,
  brush: _react.PropTypes.object,
  fullWidth: _react.PropTypes.bool,
  fullHeight: _react.PropTypes.bool,
  style: _react.PropTypes.object,
  className: _react.PropTypes.string
};
