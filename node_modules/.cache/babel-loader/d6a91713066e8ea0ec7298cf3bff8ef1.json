{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrushedArea = undefined;\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _utils = require(\"./utils.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar mouseIsInBounds = function mouseIsInBounds(mouseEvent, rectangle) {\n  var x = mouseEvent.pageX,\n      y = mouseEvent.pageY;\n  var top = rectangle.top,\n      left = rectangle.left,\n      right = rectangle.right,\n      bottom = rectangle.bottom;\n  return x >= left && x <= right && y >= top && y <= bottom;\n};\n\nvar mouseMoveExceedsThreshold = function mouseMoveExceedsThreshold(_ref, threshold) {\n  var mx0 = _ref.mx0,\n      mx1 = _ref.mx1,\n      my0 = _ref.my0,\n      my1 = _ref.my1;\n  return threshold > 0 && Math.hypot(Math.abs(mx0 - mx1), Math.abs(my0 - my1)) >= threshold;\n};\n\nvar getBrushedState = function getBrushedState(state, bounds) {\n  var mx0 = state.mx0,\n      my0 = state.my0,\n      mx1 = state.mx1,\n      my1 = state.my1;\n  var left = bounds.left,\n      top = bounds.top;\n  return {\n    y: Math.min(my1, my0) - top,\n    x: Math.min(mx1, mx0) - left,\n    height: Math.abs(my1 - my0),\n    width: Math.abs(mx1 - mx0)\n  };\n};\n\nvar ReactBrush = function (_Component) {\n  _inherits(ReactBrush, _Component);\n\n  function ReactBrush(props) {\n    _classCallCheck(this, ReactBrush);\n\n    var _this = _possibleConstructorReturn(this, (ReactBrush.__proto__ || Object.getPrototypeOf(ReactBrush)).call(this, props));\n\n    _this.state = {\n      mouseDown: false,\n      isBrushing: false,\n      mx0: 0,\n      my0: 0,\n      mx1: 0,\n      my1: 0\n    };\n\n    _this.handleMouseDown = function (e) {\n      var button = e.button,\n          mx0 = e.pageX,\n          my0 = e.pageY;\n      var _this$props = _this.props,\n          mouseDownThreshold = _this$props.mouseDownThreshold,\n          mouseMoveThreshold = _this$props.mouseMoveThreshold;\n      var delayBrush = mouseDownThreshold > 0 || moveMoveThreshold > 0;\n\n      if (button === 0) {\n        _this.setState({\n          mouseDown: true,\n          isBrushing: delayBrush ? false : true,\n          mx0: mx0,\n          my0: my0,\n          mx1: mx0,\n          my1: my0\n        }, function () {\n          if (mouseDownThreshold > 0) {\n            _this.clearMouseDownTimer();\n\n            _this._mouseDownTimer = setTimeout(function () {\n              _this.setState({\n                isBrushing: true\n              });\n            }, mouseDownThreshold);\n          }\n        });\n      }\n\n      var onMouseDown = _this.props.onMouseDown;\n\n      if (typeof onMouseDown === \"function\") {\n        onMouseDown(e);\n      }\n    };\n\n    _this.handleMouseUp = function (e) {\n      var button = e.button,\n          mx1 = e.pageX,\n          my1 = e.pageY;\n\n      if (e.button === 0) {\n        _this.clearMouseDownTimer();\n\n        _this.setState({\n          mouseDown: false,\n          isBrushing: false,\n          mx1: mx1,\n          my1: my1\n        });\n      }\n\n      var onMouseUp = _this.props.onMouseUp;\n\n      if (typeof onMouseUp === \"function\" && mouseIsInBounds(e, _this.getBounds())) {\n        _this.props.onMouseUp(e);\n      }\n    };\n\n    _this.mouseMove = function (e) {\n      var mx1 = e.pageX,\n          my1 = e.pageY;\n\n      _this.setState(function (_ref2) {\n        var mouseDown = _ref2.mouseDown,\n            isBrushing = _ref2.isBrushing;\n        var state = {\n          mx1: mx1,\n          my1: my1\n        }; // end here if the mouse is not down or brush is already in progress\n\n        if (!mouseDown || isBrushing) {\n          return state;\n        } // end here if the mouse has not moved far enough to trigger a brush\n\n\n        var _this$state = _this.state,\n            mx0 = _this$state.mx0,\n            my0 = _this$state.my0;\n\n        if (!mouseMoveExceedsThreshold({\n          mx1: mx1,\n          my1: my1,\n          mx0: mx0,\n          my0: my0\n        }, _this.props.mouseMoveThreshold)) {\n          return state;\n        }\n\n        _this.clearMouseDownTimer();\n\n        state.isBrushing = true;\n        return state;\n      });\n\n      var onMouseMove = _this.props.onMouseMove;\n\n      if (typeof onMouseMove === \"function\" && mouseIsInBounds(e, _this.getBounds())) {\n        onMouseMove(e);\n      }\n    };\n\n    _this._userSelectStyles = {};\n    return _this;\n  }\n\n  _createClass(ReactBrush, [{\n    key: \"getBounds\",\n    value: function getBounds() {\n      if (!this.container) {\n        return {\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0\n        };\n      }\n\n      var _document$documentEle = document.documentElement,\n          clientTop = _document$documentEle.clientTop,\n          clientLeft = _document$documentEle.clientLeft;\n      var _window = window,\n          pageYOffset = _window.pageYOffset,\n          pageXOffset = _window.pageXOffset;\n\n      var _container$getBoundin = this.container.getBoundingClientRect(),\n          top = _container$getBoundin.top,\n          left = _container$getBoundin.left;\n\n      var _props = this.props,\n          height = _props.height,\n          width = _props.width;\n      var vertOffset = pageYOffset - clientTop;\n      var horizontalOffset = pageXOffset - clientLeft;\n      return {\n        top: top + vertOffset,\n        left: left + horizontalOffset,\n        bottom: top + vertOffset + height,\n        right: left + horizontalOffset + width\n      };\n    }\n  }, {\n    key: \"clearMouseDownTimer\",\n    value: function clearMouseDownTimer() {\n      if (this._mouseDownTimer) {\n        clearTimeout(this._mouseDownTimer);\n        this._mouseDownTimer = null;\n      }\n    }\n  }, {\n    key: \"brushStart\",\n    value: function brushStart(nextState) {\n      // prevent text in other elements from being selected during a brush\n      var delStyle = document.documentElement.style;\n      var userSelect = delStyle.userSelect,\n          webkitUserSelect = delStyle.webkitUserSelect,\n          mozUserSelect = delStyle.mozUserSelect,\n          msUserSelect = delStyle.msUserSelect;\n      this._userSelectStyles = {\n        userSelect: userSelect,\n        webkitUserSelect: webkitUserSelect,\n        mozUserSelect: mozUserSelect,\n        msUserSelect: msUserSelect\n      };\n      delStyle.userSelect = \"none\";\n      delStyle.webkitUserSelect = \"none\";\n      delStyle.mozUserSelect = \"none\";\n      delStyle.msUserSelect = \"none\";\n      var onBrushStart = this.props.onBrushStart;\n\n      if (typeof onBrushStart === \"function\") {\n        onBrushStart(getBrushedState(nextState, this.getBounds()));\n      }\n    }\n  }, {\n    key: \"brushStop\",\n    value: function brushStop(nextState) {\n      // restore previous user-select styles\n      var delStyle = document.documentElement.style;\n      var _userSelectStyles = this._userSelectStyles,\n          userSelect = _userSelectStyles.userSelect,\n          webkitUserSelect = _userSelectStyles.webkitUserSelect,\n          mozUserSelect = _userSelectStyles.mozUserSelect,\n          msUserSelect = _userSelectStyles.msUserSelect;\n      delStyle.userSelect = userSelect;\n      delStyle.webkitUserSelect = webkitUserSelect;\n      delStyle.mozUserSelect = mozUserSelect;\n      delStyle.msUserSelect = msUserSelect;\n      var onBrushStop = this.props.onBrushStop;\n\n      if (typeof onBrushStop === \"function\") {\n        onBrushStop(getBrushedState(nextState, this.getBounds()));\n      }\n    }\n  }, {\n    key: \"brushChange\",\n    value: function brushChange(nextState) {\n      var onBrushChange = this.props.onBrushChange;\n\n      if (typeof onBrushChange === \"function\") {\n        onBrushChange(getBrushedState(nextState, this.getBounds()));\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, _ref3) {\n      var nextx = _ref3.mx1,\n          nexty = _ref3.my1,\n          nextState = _objectWithoutProperties(_ref3, [\"mx1\", \"my1\"]);\n\n      var _state = this.state,\n          x = _state.mx1,\n          y = _state.my1,\n          state = _objectWithoutProperties(_state, [\"mx1\", \"my1\"]);\n\n      if (!(0, _utils.shallowEqual)(this.props, nextProps) || !(0, _utils.shallowEqual)(state, nextState)) {\n        return true;\n      } // only re-render on mouse movement if the user is actively brushing\n\n\n      if (nextState.isBrushing === true) {\n        return x !== nextx || y !== nexty;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"componentWillUpdate\",\n    value: function componentWillUpdate(nextProps, nextState) {\n      var _state2 = this.state,\n          isBrushing = _state2.isBrushing,\n          x = _state2.x1,\n          y = _state2.y1;\n      var nextIsBrushing = nextState.isBrushing,\n          nextx = nextState.x1,\n          nexty = nextState.y1; // are we starting a brush?\n\n      if (nextIsBrushing === true && isBrushing === false) {\n        this.brushStart(nextState);\n        return;\n      } // are we ending a brush?\n\n\n      if (nextIsBrushing === false && isBrushing === true) {\n        this.brushStop(nextState);\n        return;\n      } // are we updating the brush?\n\n\n      if (nextIsBrushing === true && (nextx != x || nexty != y)) {\n        this.brushChange(nextState);\n        return;\n      }\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      window.addEventListener(\"mouseup\", this.handleMouseUp);\n      window.addEventListener(\"mousemove\", this.mouseMove);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      window.removeEventListener(\"mouseup\", this.handleMouseUp);\n      window.removeEventListener(\"mousemove\", this.mouseMove);\n      this.clearMouseDownTimer();\n    }\n  }, {\n    key: \"renderOverlay\",\n    value: function renderOverlay() {\n      var _props2 = this.props,\n          _props2$brushedArea = _props2.brushedArea,\n          brushedArea = _props2$brushedArea === undefined ? _react2.default.createElement(BrushedArea, null) : _props2$brushedArea,\n          height = _props2.height,\n          width = _props2.width;\n      var container = this.getBounds();\n      var brush = getBrushedState(this.state, container);\n      var brushProps = {\n        brush: brush,\n        container: container\n      };\n      var _state3 = this.state,\n          brushStart = _state3.brushStart,\n          mouseUp = _state3.mouseUp;\n      var isBrushing = this.state.isBrushing;\n      return _react2.default.createElement(\"g\", null, isBrushing && ((0, _react.isValidElement)(brushedArea) ? (0, _react.cloneElement)(brushedArea, brushProps) : brushedArea(brushProps)), _react2.default.createElement(\"rect\", {\n        width: width,\n        height: height,\n        style: {\n          opacity: 0,\n          cursor: isBrushing ? \"crosshair\" : \"auto\"\n        }\n      }));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _props3 = this.props,\n          onMouseUp = _props3.onMouseUp,\n          onMouseMove = _props3.onMouseMove,\n          onBrushStop = _props3.onBrushStop,\n          onBrushStart = _props3.onBrushStart,\n          onBrushChange = _props3.onBrushChange,\n          brushedArea = _props3.brushedArea,\n          mouseMoveThreshold = _props3.mouseMoveThreshold,\n          mouseDownThreshold = _props3.mouseDownThreshold,\n          Tag = _props3.tag,\n          children = _props3.children,\n          width = _props3.width,\n          height = _props3.height,\n          onMouseDown = _props3.onMouseDown,\n          props = _objectWithoutProperties(_props3, [\"onMouseUp\", \"onMouseMove\", \"onBrushStop\", \"onBrushStart\", \"onBrushChange\", \"brushedArea\", \"mouseMoveThreshold\", \"mouseDownThreshold\", \"tag\", \"children\", \"width\", \"height\", \"onMouseDown\"]);\n\n      if (Tag === \"svg\") {\n        props.height = height;\n        props.width = width;\n      }\n\n      var _state4 = this.state,\n          brushStart = _state4.brushStart,\n          mouseUp = _state4.mouseUp;\n      var isBrushing = this.state.isBrushing;\n      return _react2.default.createElement(Tag, _extends({\n        onMouseDown: this.handleMouseDown\n      }, props, {\n        ref: function ref(r) {\n          _this2.container = r;\n        }\n      }), !isBrushing && this.renderOverlay(), children, isBrushing && this.renderOverlay());\n    }\n  }]);\n\n  return ReactBrush;\n}(_react.Component);\n\nReactBrush.propTypes = {\n  width: _react.PropTypes.number.isRequired,\n  height: _react.PropTypes.number.isRequired,\n  onBrushStart: _react.PropTypes.func,\n  onBrushStop: _react.PropTypes.func,\n  onBrushChange: _react.PropTypes.func,\n  brushedArea: _react.PropTypes.oneOfType([_react.PropTypes.element, _react.PropTypes.func]),\n  tag: _react.PropTypes.string,\n  mouseMoveThreshold: _react.PropTypes.number,\n  mouseDownThreshold: _react.PropTypes.number\n};\nReactBrush.defaultProps = {\n  tag: \"svg\",\n  mouseDownThreshold: 500,\n  mouseMoveThreshold: 5\n};\nexports.default = ReactBrush;\n\nvar BrushedArea = exports.BrushedArea = function BrushedArea(_ref4) {\n  var brush = _ref4.brush,\n      container = _ref4.container,\n      style = _ref4.style,\n      fullWidth = _ref4.fullWidth,\n      fullHeight = _ref4.fullHeight,\n      className = _ref4.className;\n\n  if (!(container && brush)) {\n    return null;\n  }\n\n  var brushWidth = brush.width,\n      brushHeight = brush.height,\n      brushX = brush.x,\n      brushY = brush.y;\n  var top = container.top,\n      left = container.left,\n      right = container.right,\n      bottom = container.bottom;\n  var containerWidth = right - left;\n  var containterHeight = bottom - top;\n  var x = 0;\n  var y = 0;\n  var width = containerWidth;\n  var height = containterHeight;\n\n  if (!fullWidth) {\n    var _ref5 = brushX < 0 ? [0, brushWidth + brushX] : [brushX, brushX + brushWidth > containerWidth ? containerWidth - brushX : brushWidth];\n\n    var _ref6 = _slicedToArray(_ref5, 2);\n\n    x = _ref6[0];\n    width = _ref6[1];\n  }\n\n  if (!fullHeight) {\n    var _ref7 = brushY < 0 ? [0, brushHeight + brushY] : [brushY, brushY + brushHeight > containterHeight ? containterHeight - brushY : brushHeight];\n\n    var _ref8 = _slicedToArray(_ref7, 2);\n\n    y = _ref8[0];\n    height = _ref8[1];\n  }\n\n  return _react2.default.createElement(\"rect\", {\n    width: width,\n    height: height,\n    className: className,\n    x: x,\n    y: y,\n    style: _extends({\n      fill: \"black\",\n      opacity: 0.3\n    }, style)\n  });\n};\n\nBrushedArea.propTypes = {\n  container: _react.PropTypes.object,\n  brush: _react.PropTypes.object,\n  fullWidth: _react.PropTypes.bool,\n  fullHeight: _react.PropTypes.bool,\n  style: _react.PropTypes.object,\n  className: _react.PropTypes.string\n};","map":null,"metadata":{},"sourceType":"script"}